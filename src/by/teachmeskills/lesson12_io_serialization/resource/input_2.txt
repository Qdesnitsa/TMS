Чудо Java шалаш байт-код.

Основная особенность Java, которая позволяет решать описанные выше проблемы обеспечения безопасности и переносимости программ, состоит в том, что
компилятор Java выдает не исполняемый код, а так называемый байт-код - в высшей степени оптимизированный набор инструкций, предназначенных для выполнения в исполняющей системе Java, называемой виртуалъной машиной Jаvа 
(Java Virtual Machine -JVM). Собственно говоря, первоначальная версия виртуальной
машины JVМ разрабатывалась в качестве интерпретатора байт-кода. Это может
вызывать недоумение, поскольку для обеспечения максимальной производительности компиляторы многих современных языов программирования призваны
создавать исполняемый код. Но то, что программа нajava интерпретируется виртуальной машиной JVМ, как раз помогает решить основные проблемы разработки
программ для Интернета. И вот почему.
Трансляция программы Java в байт-код значительно упрощает ее выполнение
в разнотипных средах, поскольку на каждой платформе необходимо реализовать
только виртуальную машину JVМ. Если в отдельной системе имеется исполняющий пакет, в ней можно выполнять любую программу на Java. Следует, однако,
иметь в виду, что все виртуальные машины JVМ на разных платформах, несмотря
на некоторые отличия и особенности их реализации, способны правильно интерпретировать один и тот же байт-код. Если бы программа нajava компилировалась в машинозависимый код, то для каждого типа процессоров, подключенных
к Интернету, должны были бы существовать отдельные версии одной и той же
программы. Ясно, что такое решение неприемлемо. Таким образом, организация
выполнения байт-кода виртуальной машиной JVМ - простейший способ создания
по-настоящему переносимых программ.
Тот факт, что программа нa Java выполняется виртуальной машиной JVМ, способствует также повышению ее безопасности. Виртуальная машина JVМ управляет выполнением программы, поэтому она может изолировать программу и воспрепятствовать возникновению побочных эффектов от ее выполнения за пределами
данной системы. Как станет ясно в дальнейшем, ряд ограничений, существующих
в языке jаvа, также способствует повышению безопасности.
В общем, когда программа компилируется в промежуточную форму, а затем интерпретируется виртуальной машиной JVM, она выполняется медленнее, чем если
бы она была скомпилирована в исполняемый код. Но в Java это отличие в производительности не слишком заметно. Байт-код существенно оптимизирован, и поэтому его применение позволяет виртуальной машине JVМ выполнять программы
значительно быстрее, чем следовало ожидать.
Язык Java бьш задуман как интерпретируемый, но ничто не препятствует ему
оперативно выполнять компиляцию байт-кода в машинозависимый код для повышения производительности. Поэтому вскоре после выпускаjаvа появилась технология HotSpot, которая предоставляет динамu'Ческuй компилятор (или так называемый рт-компилятор) байт-кода. Если динамический компилятор входит в состав
виртуальной машины JVМ, то избранные фрагменты байт-кода компилируются
в исполняемый код по частям, в реальном времени и по требованию. Важно понимать, что одновременная компиляция всей программыjаvа в исполняемый код
нецелесообразна, поскольку Java производит различные проверки, которые могут
быть сделаны только во время выполнения. Вместо этого динамический компилятор компилирует код во время выполнения по мере надобности. Более того,
компилируются не все фрагменты байт-кода, а только те, которым компиляция
принесет выгоду, а остальной код просто интерпретируется. Тем не менее принцип динамической компиляции обеспечивает значительное повышение производительности. Даже при динамической компиляции байт-кода характеристики
переносимости и безопасности сохраняются, поскольку виртуальная машина JVМ
по-прежнему отвечает за целостность исполняющей среды.

Объектно-ориентированное программирование.

Объектно-ориентированное программирование (ООП) составляет основу
Java. По существу, все программы на Java являются в какой-то степени объектноориентированными. Язык Java связан с ООП настолько тесно, что прежде чем
приступить к написанию на нем даже простейших программ, следует вначале ознакомиться с основными принципами ООП. Поэтому начнем с рассмотрения теоретических вопросов ООП.

Две методики.

Все компьютерные программы состоят из двух элементов: кода и данных. Более
того, программа концептуально может быть организована вокруг своего кода или
своих данных. Иными словами, организация одних программ определяется тем,
"что происходит", а других - тем, "на что оказывается влияние''. Существуют две
методики создания программ. Первая из них называется моделъю, ориентированной 
на nроцессы и характеризует программу как последовательность линейных шагов
(т.е.кода). Модель, ориентированную на процессы, можно рассматривать в качестве кода, воздействующего на данные. Такая модель довольно успешно применяется
в процедурных языках вроде С. Но, как отмечалось в главе 1, подобный подход порождает ряд трудностей в связи с увеличением размеров и сложности программ.
С целью преодолеть увеличение сложности программ бьша начата разработка подхода, называемого объективно-риентированным программированием. Объектноориентированное программирование позволяет организовать программу вокруг
ее данных (т.е.объектов) и набора вполне определенных интерфейсов с этими
данными. Объектно-ориентированную программу можно охарактеризовать как
данные, управляющие доступам к коду. Как будет показано далее, передавая функции
управления данными, можно получить несколько организационных преимуществ.

Абстракция.

Важным элементом ООП является абстракция. Человеку свойственно представлять сложные явления и объекты, прибегая к абстракции. Например, люди представляют себе автомобиль не в виде набора десятков тысяч отдельных деталей,
а в виде совершенно определенного объекта, имеющего свое особое поведение.
Эта абстракция позволяет не задумываться о сложности деталей, составляющих
автомобиль, скажем, при поездке в магазин. Можно не обращать внимания на подробности работы двигателя, коробки передач и тормозной системы. Вместо этого
объект можно использовать как единое целое.
Эффективным средством применения абстракции служат иерархические классификации. Это позволяет упрощать семантику сложных систем, разбивая их
на более управляемые части. Внешне автомобиль выглядит единым объектом. Но
стоит заглянуть внутрь, как становится ясно, что он состоит из нескольких подсистем: рулевого управления, тормозов, аудиосистемы, привязных ремней, обогревателя, навигатора и т.п. Каждая из этих подсистем, в свою очередь, собрана из
более специализированных узлов. Например, аудиосистема состоит из радиоприемника, проигрывателя компакт-дисков и/или аудиокассет. Суть всего сказанного
состоит в том, что структуру автомобиля (или любой другой сложной системы)
можно описать с помощью иерархических абстракций.
Иерархические абстракции сложных систем можно применять и к компьютерным программам. Благодаря абстракции данные традиционной, ориентированной на процессы, программы можно преобразовать в составляющие ее объекты,
а последовательность этапов процесса - в совокупность сообщений, передаваемых между этими объектами. Таким образом, каждый из этих объектов описывает
свое особое поведение. Эти объекты можно считать конкретными сущностями,
реагирующими на сообщения, предписывающие им выполнить конкретное действие.
В этом, собственно, и состоит вся суть ООП.
Принципы ООП лежат как в основе языка Java, так и восприятия мира человеком.
Важно понимать, каким образом эти принципы реализуются в программах. Как станет
ясно в дальнейшем, ООП является еще одной, но более эффективной и естественной
методикой создания программ, способных пережить неизбежные изменения, сопровождающие жизненный цикл любого крупного программного проекта, включая зарождение общего замысла, развитие и созревание. Например, при наличии тщательно определенных объектов и ясных, надежных интерфейсов с этими объектам можно
безбоязненно и без особого труда извлекать или заменять части старой системы.

Три принципа ООП.

Все языки объектн-ориентированного программирования предоставляют механизмы, облегчающие реализацию объектн-риентированной модели. Этими
механизмами являются инкапсуляция, наследование и полиморфизм. Рассмотрим
эти принципы ООП в отдельности.

Инкапсуляция.

Механизм, связывающий код и данные, которыми он манипулирует, защищая оба
эти компонента от внешнего вмешательства и злоупотреблений, называется июсапсуляцшй. Инкапсуляцию можно считать защитной оболочкой, которая предохраняет код и данные от произвольного доступа со стороны другого кода, находящегося
снаружи оболочки. Доступ к коду и данным, находящимся внутри оболочки, строго
контролируется тщательно определенным интерфейсом. Чтобы провести аналогию с реальным миром, рассмотрим автоматическую коробку передач автомобиля.
Она инкапсулирует немало сведений об автомобиле, в том числе величину ускорения, крутизну поверхности, по которой совершается движение, а также положение
рычага переключения скоростей. Пользователь (в данном случае водитель) может
оказывать влияние на эту сложную инкапсуляцию только одним способом: перемещая рычаг переключения скоростей. На коробку передач нельзя воздействовать,
например, с помощью индикатора поворота или дворников. Таким образом, рычаг
переключения скоростей является строго определенным, а по существу, единственным, интерфейсом с коробкой передач. Более того, происходящее внутри коробки
передач не влияет на объекты, находящиеся вне ее. Например, переключение передач не включает фары! Функция автоматического переключения передач инкапсулирована, и поэтому десятки изготовителей автомобилей могут реализовать ее как
угодно. Но с точки зрения водителя все эти коробки передач работают одинаково.
Аналогичный принцип можно применять и в программировании. Сильная сторона
инкапсулированного кода состоит в следующем: всем известно, как получить доступ
к нему, а следовательно, его можно использовать независимо о подробностей реализации и не опасаясь неожиданных побочных эффектов.
Основу инкапсуляции в Java составляет класс. Подробнее классы будут рассмотрены в последующих главах, а до тех пор полезно дать хотя бы краткое их описание.
Класс определяет структуру и поведение (данные и код), которые будут совместно
использоваться набором объектов. Каждый объект данного класса содержит структуру и поведение, которые определены классом, как если бы объект был "отлит"
в форме класса. Поэтому иногда объекты называют экземплярами класса. Таким образом, класс - это логическая конструкция, а объект - ее физическое воплощение.
При создании класса определяются код и данные, которые образуют этот класс.
Совместно эти элементы называются членами класса. В частности, определенные
в классе данные называются переменными-членами, или переменными экземпляра, а код,
оперирующий данными, -методами-членами, или просто методами. (То, что программирующие нa Java называют методами, программирующие на С/С++ называют функциями.) В программах, правильно написанных на Java, методы определяют, каким образом используются переменные-члены. Это означает, что поведение и интерфейс
класса определяются методами, оперирующими данными его экземпляра.
Поскольку назначение класса состоит в инкапсуляции сложной структуры программы, существуют механизмы сокрытия сложной структуры реализации в самом
классе. Каждый метод или переменная в классе могут быть помечены как закрытые
или открытые. Открытый интерфейс класса представляет все, что должны или мо-
гут знать внешние пользователи класса. Закрытые методы и данные могут быть доступны только для кода, который является членом данного класса. Следовательно,
любой другой код, не являющийся членом данного класса, не может получать доступ
к закрытому методу или переменной. Закрытые члены класса доступны другим частям программы только через открытые методы класса, и благодаря этому исключается возможность выполнения неправомерных действий. Это, конечно, означает,
что открытый интерфейс должен быть тщательно спроектирован и не должен раскрывать лишние подробности внугреннего механизма работы класса (рис 2.1).

Наследование.

Процесс, в результате которого один объект получает свойства другого, называется наследованием. Это очень важный принцип ООП, поскольку наследование
обеспечивает принцип иерархической классификации. Как отмечалось ранее,
большинство знаний становятся доступными для усвоения благодаря иерархической (т.е.нисходящей) классификации. Например, золотистый ретривер - часть
классификации собак, которая, в свою очередь, относится к классу млекопитающих,
а тот - к еще большему классу животных. Без иерархий каждый объект должен был
бы явно определять все свои характеристики. Но благодаря наследованию объект
должен определять только те из них, которые делают его особым в классе. Объект
может наследовать общие атрибуты от своего родительского объекта. Таким об-
разом, механизм наследования позволяет сделать один объект частным случаем
более общего случая. Рассмотрим этот механизм подробнее.
Как правило, большинство людей воспринимают окружающий мир в виде иерархически связанных между собой объектов, подобных животным, млекопитающим и собакам. Если требуется привести абстрактное описание животных, можно
сказать, что они обладают определенными свойствами: размеры, уровень интеллекта и костная система. Животным присущи также определенные особенности
поведения: они едят, дышат и спят. Такое описание свойств и поведения составляет определение класса животных.
Если бы потребовалось описать более конкретный класс животных, например
млекопитающих, следовало бы указать более конкретные свойства, в частности
тип зубов и молочных желез. Такое определение называется подклассом животных,
которые относятся к суперклассу (родительскому классу) млекопитающих. А поскольку млекопитающие - лишь более точно определенные животные, то они наrмдуют все свойства животных. Подкласс нижнего уровня uepapxuu классов наследует все свойства каждого из его родительских классов (рис.2.2). 

Наследование связано также с инкапсуляцией. Если отдельный класс инкапсулирует определенные свойства, то любой его подкласс будет иметь те же самые свойства плюс любые дополнительные, определяющие его специализацию (рис. 2.3).
Благодаря этому ключевому принципу сложность объектно-ориентированных программ нарастает в арифметической, а не геометрической прогрессии. Новый подкласс наследует атрибуты всех своих родительских классов и поэтому не содержит
непредсказуемые взаимодействия с большей частью остального кода системы.

Полиморфизм.

Полиморфизм ( от греч."много форм") - это принцип ООП, позволяющий использовать один и тот же интерфейс для общего класса действий. Каждое действие
зависит от конкретной ситуации. Рассмотрим в качестве примера стек, действующий как список обратного магазинного типа. Допустим, в программе требуются
стеки трех типов: для целочисленных значений, для числовых значений с плавающей точкой и для с имволов. Алгоритм реализации каждого из этих стеков остается
неизменным, нес мотря на отличия в данных, которые в них хранятся. В языке, не
являющемся объектно-ориентированным, для обращения со стеком пришлось бы
создавать три разных ряда с лужебных программ под отдельными именами. А в Java,
благодаря принципу полиморфизма, для обращения со с теком можно определить
общий ряд служе бных программ под одними и теми же общими именами.
В более общем с мысле принцип полиморфизма нередко выражается фразой
"один интерфейс, несколько методов". Это означает, что можно разработать общий интерфейс для группы с вязанных вместе действий. Такой подход позволяет
уменьшить сложность программы, поскольку один и тот же интерфейс служит
для указания общего класса действий. А выбор конкретного действия (т.е.метода) делается применительно к каждой с иrуации и входит в обязанности компилятора.
Это избавляет программис та от необходимости делать такой выбор вручную. Ему
нуж но лишь помнить об общем интерфейсе и правильно применять его.
Если продолжить аналогию с собаками, то можно сказать, что собачье обоняние - полиморфное свойство. Если собака почувствует запах кошки, она залает
и погонится за ней. А если собака почувствует запах своего корма, то у нее начнется слюноотделение, и она поспешит к своей миске. В обоих случаях действует
одно и то же чувство обоняния. Отличие лишь в том, что именно издает запах, т.е.в типе данных, воздействующих на нос собаки! Этот общий принцип можно реализовать, применив его к методам в программе нa java.

Совместное применение полиморфизма, инкапсуляции и наследования.

Если принципы полиморфизма, инкапсуляции и насле дования применяются
правильно, то они образуют совместно среду программирования, поддерж ивающую раз работку более устойчивых и масштабируемых программ, чем в том случае,
когда применяетс я модель, ориентированная на процессы. Тщательно продуманная иерархия классов служит прочным основанием для многократного использования кода, на разработку и проверку которого были затрачены время и усилия.
Инкапсуляция позволяет возвращаться к ранее созданным реализациям, не нарушая код, зависящий от открытого интерфейса применяемых в приложении классов. А полиморфизм позволяет создавать понятный, практичный, удобочитаемый
и устойчивый код.
Из двух приве денных ранее примеров из реальной жизни пример с автомобилями более полно иллюстрирует возможности ООП. Если пример с собаками вполне
подходит для расс мотрения ООП с точки зрения наследования, то пример с автомобилями имеет больше общего с программами. Садясь за руль различных типов
(подклассов) автомобилей, все водители пользуются наследованием. Независимо
от того, является ли автомобиль школьным автобусом, легковым, спортивным автомобилем или семейным микроавтобусом, все водители смогут легко найти руль,
тормоза, педаль акселератора и пользоваться ими. Немного повозившись с рычагом переключения передач, большинство людей могут даже оценить отличия ручной коробки передач от автоматической, поскольку они имеют ясное представление об общем родительском классе этих объектов - системе передач.
Пользуясь автомобилями, люди постоянно взаимодействуют с их инкапсулированными характеристиками. Педали тормоза и газа скрывают невероятную
сложность соответствующих объектов за настолько простым интерфейсом, что
для управления этими объектами достаточно нажать ступней педаль! Конкретная
реализация двигателя, тип тормозов и размер шин не оказывают никакого влияния на порядок взаимодействия с определением класса педалей.
И наконец, полиморфизм ясно отражает способность изготовителей автомобилей предлагать большое разнообразие вариантов, по сути, одного и того же
средства передвижения. Так, на автомобиле могут быть установлены система тормозов с защитой от блокировки или традиционные тормоза, рулевая система с гидроусилителем или с реечной передачей и 4-, 6- или 8-цилиндровые двигатели. Но
в любом случае придется нажать на педаль тормоза, чтобы остановиться, вращать
руль, чтобы повернуть, и нажать на педаль акселератора, чтобы автомобиль двигался быстрее. Один и тот же интерфейс может быть использован для управления
самыми разными реализациями.
Как видите, благодаря совместному применению принципов инкапсуляции,
наследования и полиморфизма отдельные детали удается превратить в объект,
называемый автомобилем. Это же относится и к компьютерным программам.
Принципы ООП позволяют составить связную, надежную, сопровождаемую программу из многих отдельных частей.
Как отмечалось в начале этого раздела, каждая программа нajava является объектно-ориентированной. Точнее говоря, в каждой программе нaJava применяются принципы инкапсуляции, наследования и полиморфизма. На первый взгляд
может показаться, что не все эти принципы проявляются в коротких примерах
программ, приведенных в остальной части этой главы и ряде последующих глав,
тем не менее они в них присутствуют. Как станет ясно в дальнейшем, многие языковые средства Java являются составной частью встроенных библиотек классов,
в которых широко применяются принципы инкапсуляции, наследования и полиморфизма. 